# -*- coding: utf-8 -*-
"""QRBT_Github.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fTSDm77wW_F5anKDYYvjKi8L8JkOTCJx
"""

import numpy as np

try:
    from qiskit import QuantumCircuit
    QISKIT_AVAILABLE = True
except ImportError:
    QISKIT_AVAILABLE = False


class VariationalQuantumLayer:
    """
    Stub variational quantum layer for QRBT.
    Right now it projects classical features -> nonlinear embedding.
    You can replace forward() with actual Qiskit circuit executions.
    """
    def __init__(self, num_qubits: int):
        self.num_qubits = num_qubits

    def forward(self, x: np.ndarray) -> np.ndarray:
        """
        x: (batch, features) -> (batch, num_qubits)
        Currently just uses a smooth nonlinear transform as a placeholder.
        """
        # Normalize input
        x_norm = (x - x.mean(axis=-1, keepdims=True)) / (x.std(axis=-1, keepdims=True) + 1e-8)
        # Toy "quantum" feature map
        phi = np.tanh(x_norm)[:, : self.num_qubits]
        return phi.astype(np.float32)

    def build_qiskit_circuit_example(self, params: np.ndarray):
        if not QISKIT_AVAILABLE:
            raise RuntimeError("Qiskit not installed. Install it to use real circuits.")
        qc = QuantumCircuit(self.num_qubits)
        for i in range(self.num_qubits):
            qc.ry(float(params[i]), i)
        for i in range(self.num_qubits - 1):
            qc.cz(i, i + 1)
        qc.barrier()
        return qc